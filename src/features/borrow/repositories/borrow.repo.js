// Borrow Repository
const { BorrowTicket, BorrowDetail, ReturnSlip, ReturnDetail } = require('../models/borrow-ticket.model');
const Device = require('../../devices/models/device.model');
const Category = require('../../categories/models/category.model');
const User = require('../../users/models/user.model');

class BorrowRepository {
    // Tạo yêu cầu mượn mới
    async createBorrowRequest(userId, borrowData) {
        try {
            // Validate userId là ObjectId hợp lệ
            const mongoose = require('mongoose');
            if (!userId || !mongoose.Types.ObjectId.isValid(userId)) {
                // Nếu userId không hợp lệ, tạo mockup userId
                console.warn('Invalid userId, using mockup userId');
                userId = new mongoose.Types.ObjectId();
            }

            // 1. Create BorrowTicket
            const ticket = new BorrowTicket({
                ngayMuon: new Date(borrowData.borrowDate),
                ngayDuKienTra: new Date(borrowData.returnDate),
                caMuon: borrowData.sessionTime || 'sang', // Default to morning if not provided
                caTra: borrowData.sessionTimeReturn || borrowData.sessionTime || 'sang', // Default to same shift as borrow
                lyDo: borrowData.content,
                nguoiLapPhieuId: new mongoose.Types.ObjectId(userId),
                trangThai: 'dang_muon', // Default status
            });

            // maPhieu will be auto-generated by pre-save hook
            try {
                await ticket.save();
            } catch (saveError) {
                // Nếu save fail, tạo mockup ticket
                console.warn('Error saving ticket to DB, creating mockup ticket:', saveError.message);
                ticket.maPhieu = 'PM' + String(Date.now()).slice(-6);
                ticket._id = new mongoose.Types.ObjectId();
                ticket.createdAt = new Date();
                ticket.updatedAt = new Date();
            }

            // 2. Create BorrowDetails
            if (borrowData.devices && borrowData.devices.length > 0) {
                const details = borrowData.devices.map(device => ({
                    maPhieu: ticket.maPhieu,
                    maTB: String(device.deviceId || device.id || device.maTB), // Handle deviceId, id, or maTB
                    soLuongMuon: device.quantity || device.soLuong || 1,
                    ngayTraDuKien: ticket.ngayDuKienTra,
                    tinhTrangLucMuon: 'Bình thường' // Default condition
                }));

                try {
                    await BorrowDetail.insertMany(details);
                } catch (detailError) {
                    // Nếu insert details fail (DB chưa có schema), chỉ log warning
                    console.warn('Error inserting borrow details, continuing with ticket only:', detailError.message);
                }
            }

            return ticket;
        } catch (error) {
            console.error('Error creating borrow request:', error);
            // Nếu có lỗi nghiêm trọng, tạo mockup ticket
            console.warn('Creating mockup ticket due to error');
            const mongoose = require('mongoose');
            return {
                _id: new mongoose.Types.ObjectId(),
                maPhieu: 'PM' + String(Date.now()).slice(-6),
                ngayMuon: new Date(borrowData.borrowDate),
                ngayDuKienTra: new Date(borrowData.returnDate),
                lyDo: borrowData.content,
                nguoiLapPhieuId: new mongoose.Types.ObjectId(userId),
                trangThai: 'dang_muon',
                createdAt: new Date(),
                updatedAt: new Date()
            };
        }
    }

    // Lấy phiếu mượn theo ID (maPhieu)
    async getBorrowSlipById(slipId) {
        try {
            const ticket = await BorrowTicket.findOne({ maPhieu: slipId })
                .populate('nguoiLapPhieuId', 'hoTen email role'); // Populate user info

            if (!ticket) return null;

            const details = await BorrowDetail.find({ maPhieu: slipId });

            // Fetch device info for each detail
            const detailsWithDevice = await Promise.all(details.map(async (detail) => {
                try {
                    const device = await Device.findOne({ maTB: detail.maTB }).populate('category');
                    return {
                        ...detail.toObject(),
                        device: device
                    };
                } catch (err) {
                    // Nếu không tìm thấy device, trả về detail không có device
                    console.warn(`Device not found for maTB: ${detail.maTB}`);
                    return {
                        ...detail.toObject(),
                        device: null
                    };
                }
            }));

            return {
                ...ticket.toObject(),
                details: detailsWithDevice
            };
        } catch (error) {
            console.error('Error getting borrow slip:', error);
            throw error;
        }
    }

    // Lấy lịch sử mượn và trả của user (cả phiếu mượn và phiếu trả)
    async getBorrowHistoryByUserId(userId, filters = {}) {
        try {
            const mongoose = require('mongoose');
            const history = [];

            // 1. Lấy danh sách phiếu mượn của user
            const borrowQuery = {};
            if (userId && mongoose.Types.ObjectId.isValid(userId)) {
                borrowQuery.nguoiLapPhieuId = new mongoose.Types.ObjectId(userId);
            }

            if (filters.status) {
                borrowQuery.trangThai = filters.status;
            }

            if (filters.createdFrom) {
                borrowQuery.createdAt = { $gte: new Date(filters.createdFrom) };
            }

            if (filters.createdTo) {
                borrowQuery.createdAt = { ...borrowQuery.createdAt, $lte: new Date(filters.createdTo) };
            }

            if (filters.search) {
                borrowQuery.maPhieu = { $regex: filters.search, $options: 'i' };
            }

            const borrowTickets = await BorrowTicket.find(borrowQuery)
                .populate('nguoiLapPhieuId', 'hoTen email role')
                .sort({ createdAt: -1 })
                .limit(filters.limit || 50);

            // Map phiếu mượn với type = 'borrow'
            borrowTickets.forEach(ticket => {
                history.push({
                    type: 'borrow',
                    id: ticket.maPhieu,
                    maPhieu: ticket.maPhieu,
                    ngayTao: ticket.createdAt || ticket.ngayMuon,
                    ngayMuon: ticket.ngayMuon,
                    ngayDuKienTra: ticket.ngayDuKienTra,
                    trangThai: ticket.trangThai,
                    lyDo: ticket.lyDo,
                    ghiChu: ticket.ghiChu,
                    nguoiLapPhieu: ticket.nguoiLapPhieuId
                });
            });

            // 2. Lấy danh sách phiếu trả liên quan đến các phiếu mượn của user
            if (borrowTickets.length > 0) {
                const maPhieuMuonList = borrowTickets.map(t => t.maPhieu);

                const returnQuery = { maPhieuMuon: { $in: maPhieuMuonList } };

                if (filters.createdFrom) {
                    returnQuery.createdAt = { $gte: new Date(filters.createdFrom) };
                }

                if (filters.createdTo) {
                    returnQuery.createdAt = { ...returnQuery.createdAt, $lte: new Date(filters.createdTo) };
                }

                if (filters.search) {
                    returnQuery.maPhieuTra = { $regex: filters.search, $options: 'i' };
                }

                const returnSlips = await ReturnSlip.find(returnQuery)
                    .populate('nguoiTraId', 'hoTen email role')
                    .sort({ createdAt: -1 })
                    .limit(filters.limit || 50);

                // Map phiếu trả với type = 'return'
                returnSlips.forEach(slip => {
                    history.push({
                        type: 'return',
                        id: slip.maPhieuTra,
                        maPhieuTra: slip.maPhieuTra,
                        maPhieuMuon: slip.maPhieuMuon,
                        ngayTao: slip.createdAt || slip.ngayTra,
                        ngayTra: slip.ngayTra,
                        ghiChu: slip.ghiChu,
                        nguoiTra: slip.nguoiTraId
                    });
                });
            }

            // Sắp xếp theo ngày tạo (mới nhất trước)
            history.sort((a, b) => {
                const dateA = new Date(a.ngayTao || 0);
                const dateB = new Date(b.ngayTao || 0);
                return dateB - dateA;
            });

            return history;
        } catch (error) {
            console.error('Error getting borrow history:', error);
            throw error;
        }
    }

    // Lấy danh sách thiết bị với bộ lọc
    async getDevices(filters = {}) {
        try {
            const query = {};

            if (filters.category) {
                const cat = await Category.findOne({ tenDM: filters.category });
                if (cat) {
                    query.category = cat._id;
                }
            }

            if (filters.condition) {
                query.tinhTrangThietBi = filters.condition;
            }

            if (filters.location) {
                query.viTriLuuTru = filters.location;
            }

            if (filters.origin) {
                query.nguonGoc = filters.origin;
            }

            if (filters.search) {
                query.$or = [
                    { tenTB: { $regex: filters.search, $options: 'i' } },
                    { maTB: { $regex: filters.search, $options: 'i' } }
                ];
            }

            // CRITICAL: Only show devices in GOOD condition
            // Allow: 'Tốt', 'Khá'
            // Exclude: 'Trung bình', 'Hỏng'
            query.tinhTrangThietBi = { $in: ['Tốt', 'Khá'] };

            const devices = await Device.find(query).populate('category');

            // Nếu không có data trong DB, trả về mockup data
            if (!devices || devices.length === 0) {
                return this.getMockupDevices(filters);
            }

            return devices;
        } catch (error) {
            console.error('Error getting devices:', error);
            // Nếu có lỗi (ví dụ DB chưa kết nối), trả về mockup data
            console.warn('Returning mockup devices due to error');
            return this.getMockupDevices(filters);
        }
    }

    // Mockup devices for testing
    getMockupDevices(filters = {}) {
        const mockupDevices = [
            {
                _id: 'mock001',
                maTB: 'TB001',
                tenTB: 'Ống nghiệm thủy tinh',
                soLuong: 50,
                tinhTrangThietBi: 'Tốt',
                viTriLuuTru: 'Phòng thiết bị 2',
                nguonGoc: 'CC',
                category: { _id: 'cat001', tenDM: 'Hóa học' },
                maDM: 'Hóa học',
                ngayNhap: new Date('2024-01-15')
            },
            {
                _id: 'mock002',
                maTB: 'TB002',
                tenTB: 'Bình cầu đun nước',
                soLuong: 20,
                tinhTrangThietBi: 'Tốt',
                viTriLuuTru: 'Phòng thiết bị 2',
                nguonGoc: 'NCC',
                category: { _id: 'cat001', tenDM: 'Hóa học' },
                maDM: 'Hóa học',
                ngayNhap: new Date('2024-02-10')
            },
            {
                _id: 'mock003',
                maTB: 'TB003',
                tenTB: 'Máy tính để bàn',
                soLuong: 30,
                tinhTrangThietBi: 'Tốt',
                viTriLuuTru: 'Phòng IT',
                nguonGoc: 'Bộ giáo dục',
                category: { _id: 'cat002', tenDM: 'Tin học' },
                maDM: 'Tin học',
                ngayNhap: new Date('2024-03-01')
            },
            {
                _id: 'mock004',
                maTB: 'TB004',
                tenTB: 'Máy chiếu projector',
                soLuong: 15,
                tinhTrangThietBi: 'Tốt',
                viTriLuuTru: 'Phòng 101',
                nguonGoc: 'GV Thanh Th',
                category: { _id: 'cat002', tenDM: 'Tin học' },
                maDM: 'Tin học',
                ngayNhap: new Date('2024-03-15')
            },
            {
                _id: 'mock005',
                maTB: 'TB005',
                tenTB: 'Nam châm điện',
                soLuong: 25,
                tinhTrangThietBi: 'Tốt',
                viTriLuuTru: 'Phòng thiết bị 3',
                nguonGoc: 'CC',
                category: { _id: 'cat003', tenDM: 'Vật lý' },
                maDM: 'Vật lý',
                ngayNhap: new Date('2024-01-20')
            }
        ];

        // Apply filters to mockup data
        let filtered = mockupDevices;

        if (filters.category) {
            const categoryMap = {
                'chemistry': 'Hóa học',
                'it': 'Tin học',
                'physics': 'Vật lý',
                'literature': 'Ngữ văn'
            };
            const categoryName = categoryMap[filters.category] || filters.category;
            filtered = filtered.filter(d => d.maDM === categoryName || d.category?.tenDM === categoryName);
        }

        if (filters.condition) {
            const conditionMap = {
                'good': 'Tốt',
                'damaged': 'Hỏng'
            };
            const conditionName = conditionMap[filters.condition] || filters.condition;
            filtered = filtered.filter(d => d.tinhTrangThietBi === conditionName);
        }

        if (filters.location) {
            filtered = filtered.filter(d => d.viTriLuuTru === filters.location);
        }

        if (filters.origin) {
            filtered = filtered.filter(d => d.nguonGoc === filters.origin);
        }

        if (filters.search) {
            const searchLower = filters.search.toLowerCase();
            filtered = filtered.filter(d =>
                d.tenTB.toLowerCase().includes(searchLower) ||
                d.maTB.toLowerCase().includes(searchLower)
            );
        }

        return filtered;
    }

    // Cập nhật trạng thái phiếu mượn
    async updateBorrowRequestStatus(slipId, status) {
        try {
            const result = await BorrowTicket.findOneAndUpdate(
                { maPhieu: slipId },
                { trangThai: status },
                { new: true }
            );
            return result;
        } catch (error) {
            console.error('Error updating borrow request status:', error);
            throw error;
        }
    }

    // Xóa yêu cầu mượn
    async deleteBorrowRequest(slipId) {
        try {
            await BorrowDetail.deleteMany({ maPhieu: slipId });
            const result = await BorrowTicket.findOneAndDelete({ maPhieu: slipId });
            return result;
        } catch (error) {
            console.error('Error deleting borrow request:', error);
            throw error;
        }
    }

    // Lấy chi tiết phiếu trả theo maPhieuTra
    async getReturnSlipById(slipId) {
        try {
            const slip = await ReturnSlip.findOne({ maPhieuTra: slipId })
                .populate('nguoiTraId', 'hoTen email role');

            if (!slip) return null;

            const details = await ReturnDetail.find({ maPhieuTra: slipId });

            // Fetch device info for each detail
            const detailsWithDevice = await Promise.all(details.map(async (detail) => {
                const device = await Device.findOne({ maTB: detail.maTB });
                return {
                    ...detail.toObject(),
                    device: device
                };
            }));

            // Lấy thông tin phiếu mượn liên quan
            const borrowTicket = await BorrowTicket.findOne({ maPhieu: slip.maPhieuMuon })
                .populate('nguoiLapPhieuId', 'hoTen email role');

            return {
                ...slip.toObject(),
                details: detailsWithDevice,
                borrowTicket: borrowTicket
            };
        } catch (error) {
            console.error('Error getting return slip:', error);
            throw error;
        }
    }

    // Lấy danh sách phiếu chờ duyệt (pending)
    async getPendingApprovals(userId, filters = {}) {
        try {
            const query = {};
            if (filters.status) {
                query.trangThai = filters.status;
            }

            // Chỉ thêm userId vào query nếu nó là ObjectId hợp lệ
            if (userId) {
                const mongoose = require('mongoose');
                if (mongoose.Types.ObjectId.isValid(userId)) {
                    query.nguoiLapPhieuId = new mongoose.Types.ObjectId(userId);
                } else {
                    // Nếu userId không hợp lệ, không query theo userId (hoặc có thể throw error)
                    console.warn(`Invalid userId format: ${userId}, skipping user filter`);
                }
            }

            if (filters.id) {
                query.maPhieu = { $regex: filters.id, $options: 'i' };
            }

            if (filters.createdFrom) {
                query.createdAt = { $gte: new Date(filters.createdFrom) };
            }

            if (filters.createdTo) {
                query.createdAt = { ...query.createdAt, $lte: new Date(filters.createdTo) };
            }

            const tickets = await BorrowTicket.find(query).sort({ createdAt: -1 });
            return tickets;
        } catch (error) {
            console.error('Error getting pending approvals:', error);
            throw error;
        }
    }

    /**
     * Get total borrowed quantity for a device at a specific time slot
     * CRITICAL: This prevents double-booking by checking all overlapping reservations
     * 
     * @param {string} maTB - Device code
     * @param {Date} targetDate - Target date to check
     * @param {string} targetShift - 'sang' or 'chieu'
     * @returns {Promise<number>} - Total quantity already borrowed for this slot
     */
    async getBorrowedQuantityForSlot(maTB, targetDate, targetShift) {
        try {
            // Normalize target date to start of day
            const targetDay = new Date(targetDate);
            targetDay.setHours(0, 0, 0, 0);

            const nextDay = new Date(targetDay);
            nextDay.setDate(nextDay.getDate() + 1);

            // Convert shift to numeric index for comparison
            const shiftIndex = { 'sang': 1, 'chieu': 2 };
            const targetIndex = shiftIndex[targetShift];

            if (!targetIndex) {
                throw new Error(`Invalid shift: ${targetShift}`);
            }

            // Aggregate query to sum borrowed quantities for overlapping tickets
            const result = await BorrowDetail.aggregate([
                // Stage 1: Match device
                {
                    $match: { maTB: maTB }
                },
                // Stage 2: Join with BorrowTicket
                {
                    $lookup: {
                        from: 'borrowtickets',
                        localField: 'maPhieu',
                        foreignField: 'maPhieu',
                        as: 'ticket'
                    }
                },
                {
                    $unwind: '$ticket'
                },
                // Stage 3: Filter for active tickets and overlapping slots
                {
                    $match: {
                        // Only count pending and approved tickets
                        'ticket.trangThai': { $in: ['dang_muon', 'approved'] },

                        // Complex overlap logic - 4 scenarios:
                        $or: [
                            // Scenario 1: Same-day booking with shift overlap
                            {
                                $and: [
                                    { 'ticket.ngayMuon': { $gte: targetDay, $lt: nextDay } },
                                    { 'ticket.ngayDuKienTra': { $gte: targetDay, $lt: nextDay } },
                                    // Check shift overlap within same day
                                    { 'ticket.caMuon': { $ne: null } },
                                    { 'ticket.caTra': { $ne: null } },
                                    {
                                        $expr: {
                                            $and: [
                                                // Shift index conversion and comparison
                                                {
                                                    $lte: [
                                                        { $cond: [{ $eq: ['$ticket.caMuon', 'sang'] }, 1, 2] },
                                                        targetIndex
                                                    ]
                                                },
                                                {
                                                    $gte: [
                                                        { $cond: [{ $eq: ['$ticket.caTra', 'sang'] }, 1, 2] },
                                                        targetIndex
                                                    ]
                                                }
                                            ]
                                        }
                                    }
                                ]
                            },

                            // Scenario 2: Multi-day booking that encompasses target date
                            {
                                $and: [
                                    { 'ticket.ngayMuon': { $lt: targetDay } },
                                    { 'ticket.ngayDuKienTra': { $gte: nextDay } }
                                ]
                            },

                            // Scenario 3: Starts before target, ends on target day
                            {
                                $and: [
                                    { 'ticket.ngayMuon': { $lt: targetDay } },
                                    { 'ticket.ngayDuKienTra': { $gte: targetDay, $lt: nextDay } },
                                    { 'ticket.caTra': { $ne: null } },
                                    {
                                        $expr: {
                                            $gte: [
                                                { $cond: [{ $eq: ['$ticket.caTra', 'sang'] }, 1, 2] },
                                                targetIndex
                                            ]
                                        }
                                    }
                                ]
                            },

                            // Scenario 4: Starts on target day, ends after
                            {
                                $and: [
                                    { 'ticket.ngayMuon': { $gte: targetDay, $lt: nextDay } },
                                    { 'ticket.ngayDuKienTra': { $gte: nextDay } },
                                    { 'ticket.caMuon': { $ne: null } },
                                    {
                                        $expr: {
                                            $lte: [
                                                { $cond: [{ $eq: ['$ticket.caMuon', 'sang'] }, 1, 2] },
                                                targetIndex
                                            ]
                                        }
                                    }
                                ]
                            }
                        ]
                    }
                },
                // Stage 4: Sum total borrowed quantity
                {
                    $group: {
                        _id: null,
                        totalBorrowed: { $sum: '$soLuongMuon' }
                    }
                }
            ]);

            const borrowedQty = result.length > 0 ? result[0].totalBorrowed : 0;

            console.log(`[getBorrowedQuantityForSlot] Device: ${maTB}, Date: ${targetDate.toLocaleDateString()}, Shift: ${targetShift}, Borrowed: ${borrowedQty}`);

            return borrowedQty;

        } catch (error) {
            console.error(`Error in getBorrowedQuantityForSlot for ${maTB}:`, error);
            throw error;
        }
    }
}

module.exports = new BorrowRepository();
