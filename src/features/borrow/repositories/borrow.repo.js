// Borrow Repository
const { BorrowTicket, BorrowDetail } = require('../models/borrow-ticket.model');
const Device = require('../../devices/models/device.model');
const Category = require('../../categories/models/category.model');

class BorrowRepository {
    // Tạo yêu cầu mượn mới
    async createBorrowRequest(userId, borrowData) {
        try {
            // Validate userId là ObjectId hợp lệ
            const mongoose = require('mongoose');
            if (!userId || !mongoose.Types.ObjectId.isValid(userId)) {
                throw new Error('Invalid userId: must be a valid ObjectId');
            }
            
            // 1. Create BorrowTicket
            const ticket = new BorrowTicket({
                ngayMuon: new Date(borrowData.borrowDate),
                ngayDuKienTra: new Date(borrowData.returnDate),
                lyDo: borrowData.content,
                nguoiLapPhieuId: new mongoose.Types.ObjectId(userId),
                trangThai: 'dang_muon', // Default status
            });

            // maPhieu will be auto-generated by pre-save hook
            await ticket.save();

            // 2. Create BorrowDetails
            if (borrowData.devices && borrowData.devices.length > 0) {
                const details = borrowData.devices.map(device => ({
                    maPhieu: ticket.maPhieu,
                    maTB: device.id || device.maTB, // Handle both id or maTB
                    soLuongMuon: device.quantity || device.soLuong,
                    ngayTraDuKien: ticket.ngayDuKienTra,
                    tinhTrangLucMuon: 'Bình thường' // Default condition
                }));

                await BorrowDetail.insertMany(details);
            }

            return ticket;
        } catch (error) {
            console.error('Error creating borrow request:', error);
            throw error;
        }
    }

    // Lấy phiếu mượn theo ID (maPhieu)
    async getBorrowSlipById(slipId) {
        try {
            const ticket = await BorrowTicket.findOne({ maPhieu: slipId })
                .populate('nguoiLapPhieuId', 'name email role'); // Populate user info

            if (!ticket) return null;

            const details = await BorrowDetail.find({ maPhieu: slipId });

            // Fetch device info for each detail
            const detailsWithDevice = await Promise.all(details.map(async (detail) => {
                const device = await Device.findOne({ maTB: detail.maTB });
                return {
                    ...detail.toObject(),
                    device: device
                };
            }));

            return {
                ...ticket.toObject(),
                details: detailsWithDevice
            };
        } catch (error) {
            console.error('Error getting borrow slip:', error);
            throw error;
        }
    }

    // Lấy lịch sử mượn của user
    async getBorrowHistoryByUserId(userId, filters = {}) {
        try {
            const query = {};
            
            // Chỉ thêm userId vào query nếu nó là ObjectId hợp lệ
            if (userId) {
                const mongoose = require('mongoose');
                if (mongoose.Types.ObjectId.isValid(userId)) {
                    query.nguoiLapPhieuId = new mongoose.Types.ObjectId(userId);
                } else {
                    console.warn(`Invalid userId format: ${userId}, skipping user filter`);
                }
            }

            if (filters.status) {
                query.trangThai = filters.status;
            }

            if (filters.dateFrom) {
                query.ngayMuon = { $gte: new Date(filters.dateFrom) };
            }

            if (filters.dateTo) {
                query.ngayMuon = { ...query.ngayMuon, $lte: new Date(filters.dateTo) };
            }

            const tickets = await BorrowTicket.find(query)
                .sort({ createdAt: -1 })
                .limit(filters.limit || 20);

            return tickets;
        } catch (error) {
            console.error('Error getting borrow history:', error);
            throw error;
        }
    }

    // Lấy danh sách thiết bị với bộ lọc
    async getDevices(filters = {}) {
        try {
            const query = {};

            if (filters.category) {
                const cat = await Category.findOne({ tenDM: filters.category });
                if (cat) {
                    query.category = cat._id;
                }
            }

            if (filters.condition) {
                query.tinhTrangThietBi = filters.condition;
            }

            if (filters.location) {
                query.viTriLuuTru = filters.location;
            }

            if (filters.origin) {
                query.nguonGoc = filters.origin;
            }

            if (filters.search) {
                query.$or = [
                    { tenTB: { $regex: filters.search, $options: 'i' } },
                    { maTB: { $regex: filters.search, $options: 'i' } }
                ];
            }

            const devices = await Device.find(query).populate('category');
            return devices;
        } catch (error) {
            console.error('Error getting devices:', error);
            throw error;
        }
    }

    // Cập nhật trạng thái phiếu mượn
    async updateBorrowRequestStatus(slipId, status) {
        try {
            const result = await BorrowTicket.findOneAndUpdate(
                { maPhieu: slipId },
                { trangThai: status },
                { new: true }
            );
            return result;
        } catch (error) {
            console.error('Error updating borrow request status:', error);
            throw error;
        }
    }

    // Xóa yêu cầu mượn
    async deleteBorrowRequest(slipId) {
        try {
            await BorrowDetail.deleteMany({ maPhieu: slipId });
            const result = await BorrowTicket.findOneAndDelete({ maPhieu: slipId });
            return result;
        } catch (error) {
            console.error('Error deleting borrow request:', error);
            throw error;
        }
    }

    // Lấy danh sách phiếu chờ duyệt (pending)
    async getPendingApprovals(userId, filters = {}) {
        try {
            const query = {};
            if (filters.status) {
                query.trangThai = filters.status;
            }

            // Chỉ thêm userId vào query nếu nó là ObjectId hợp lệ
            if (userId) {
                const mongoose = require('mongoose');
                if (mongoose.Types.ObjectId.isValid(userId)) {
                    query.nguoiLapPhieuId = new mongoose.Types.ObjectId(userId);
                } else {
                    // Nếu userId không hợp lệ, không query theo userId (hoặc có thể throw error)
                    console.warn(`Invalid userId format: ${userId}, skipping user filter`);
                }
            }

            if (filters.id) {
                query.maPhieu = { $regex: filters.id, $options: 'i' };
            }

            if (filters.createdFrom) {
                query.createdAt = { $gte: new Date(filters.createdFrom) };
            }

            if (filters.createdTo) {
                query.createdAt = { ...query.createdAt, $lte: new Date(filters.createdTo) };
            }

            const tickets = await BorrowTicket.find(query).sort({ createdAt: -1 });
            return tickets;
        } catch (error) {
            console.error('Error getting pending approvals:', error);
            throw error;
        }
    }
}

module.exports = new BorrowRepository();
