// Borrow Repository
const { BorrowTicket, BorrowDetail, ReturnSlip, ReturnDetail } = require('../models/borrow-ticket.model');
const Device = require('../../devices/models/device.model');
const Category = require('../../categories/models/category.model');
const User = require('../../users/models/user.model');

class BorrowRepository {
    // Tạo yêu cầu mượn mới
    async createBorrowRequest(userId, borrowData) {
        try {
            // Validate userId là ObjectId hợp lệ
            const mongoose = require('mongoose');
            if (!userId || !mongoose.Types.ObjectId.isValid(userId)) {
                throw new Error('Invalid userId: must be a valid ObjectId');
            }
            
            // 1. Create BorrowTicket
            const ticket = new BorrowTicket({
                ngayMuon: new Date(borrowData.borrowDate),
                ngayDuKienTra: new Date(borrowData.returnDate),
                lyDo: borrowData.content,
                nguoiLapPhieuId: new mongoose.Types.ObjectId(userId),
                trangThai: 'dang_muon', // Default status
            });

            // maPhieu will be auto-generated by pre-save hook
            await ticket.save();

            // 2. Create BorrowDetails
            if (borrowData.devices && borrowData.devices.length > 0) {
                const details = borrowData.devices.map(device => ({
                    maPhieu: ticket.maPhieu,
                    maTB: device.id || device.maTB, // Handle both id or maTB
                    soLuongMuon: device.quantity || device.soLuong,
                    ngayTraDuKien: ticket.ngayDuKienTra,
                    tinhTrangLucMuon: 'Bình thường' // Default condition
                }));

                await BorrowDetail.insertMany(details);
            }

            return ticket;
        } catch (error) {
            console.error('Error creating borrow request:', error);
            throw error;
        }
    }

    // Lấy phiếu mượn theo ID (maPhieu)
    async getBorrowSlipById(slipId) {
        try {
            const ticket = await BorrowTicket.findOne({ maPhieu: slipId })
                .populate('nguoiLapPhieuId', 'hoTen email role'); // Populate user info

            if (!ticket) return null;

            const details = await BorrowDetail.find({ maPhieu: slipId });

            // Fetch device info for each detail
            const detailsWithDevice = await Promise.all(details.map(async (detail) => {
                const device = await Device.findOne({ maTB: detail.maTB });
                return {
                    ...detail.toObject(),
                    device: device
                };
            }));

            return {
                ...ticket.toObject(),
                details: detailsWithDevice
            };
        } catch (error) {
            console.error('Error getting borrow slip:', error);
            throw error;
        }
    }

    // Lấy lịch sử mượn và trả của user (cả phiếu mượn và phiếu trả)
    async getBorrowHistoryByUserId(userId, filters = {}) {
        try {
            const mongoose = require('mongoose');
            const history = [];

            // 1. Lấy danh sách phiếu mượn của user
            const borrowQuery = {};
            if (userId && mongoose.Types.ObjectId.isValid(userId)) {
                borrowQuery.nguoiLapPhieuId = new mongoose.Types.ObjectId(userId);
            }

            if (filters.status) {
                borrowQuery.trangThai = filters.status;
            }

            if (filters.createdFrom) {
                borrowQuery.createdAt = { $gte: new Date(filters.createdFrom) };
            }

            if (filters.createdTo) {
                borrowQuery.createdAt = { ...borrowQuery.createdAt, $lte: new Date(filters.createdTo) };
            }

            if (filters.search) {
                borrowQuery.maPhieu = { $regex: filters.search, $options: 'i' };
            }

            const borrowTickets = await BorrowTicket.find(borrowQuery)
                .populate('nguoiLapPhieuId', 'hoTen email role')
                .sort({ createdAt: -1 })
                .limit(filters.limit || 50);

            // Map phiếu mượn với type = 'borrow'
            borrowTickets.forEach(ticket => {
                history.push({
                    type: 'borrow',
                    id: ticket.maPhieu,
                    maPhieu: ticket.maPhieu,
                    ngayTao: ticket.createdAt || ticket.ngayMuon,
                    ngayMuon: ticket.ngayMuon,
                    ngayDuKienTra: ticket.ngayDuKienTra,
                    trangThai: ticket.trangThai,
                    lyDo: ticket.lyDo,
                    ghiChu: ticket.ghiChu,
                    nguoiLapPhieu: ticket.nguoiLapPhieuId
                });
            });

            // 2. Lấy danh sách phiếu trả liên quan đến các phiếu mượn của user
            if (borrowTickets.length > 0) {
                const maPhieuMuonList = borrowTickets.map(t => t.maPhieu);
                
                const returnQuery = { maPhieuMuon: { $in: maPhieuMuonList } };
                
                if (filters.createdFrom) {
                    returnQuery.createdAt = { $gte: new Date(filters.createdFrom) };
                }

                if (filters.createdTo) {
                    returnQuery.createdAt = { ...returnQuery.createdAt, $lte: new Date(filters.createdTo) };
                }

                if (filters.search) {
                    returnQuery.maPhieuTra = { $regex: filters.search, $options: 'i' };
                }

                const returnSlips = await ReturnSlip.find(returnQuery)
                    .populate('nguoiTraId', 'hoTen email role')
                    .sort({ createdAt: -1 })
                    .limit(filters.limit || 50);

                // Map phiếu trả với type = 'return'
                returnSlips.forEach(slip => {
                    history.push({
                        type: 'return',
                        id: slip.maPhieuTra,
                        maPhieuTra: slip.maPhieuTra,
                        maPhieuMuon: slip.maPhieuMuon,
                        ngayTao: slip.createdAt || slip.ngayTra,
                        ngayTra: slip.ngayTra,
                        ghiChu: slip.ghiChu,
                        nguoiTra: slip.nguoiTraId
                    });
                });
            }

            // Sắp xếp theo ngày tạo (mới nhất trước)
            history.sort((a, b) => {
                const dateA = new Date(a.ngayTao || 0);
                const dateB = new Date(b.ngayTao || 0);
                return dateB - dateA;
            });

            return history;
        } catch (error) {
            console.error('Error getting borrow history:', error);
            throw error;
        }
    }

    // Lấy danh sách thiết bị với bộ lọc
    async getDevices(filters = {}) {
        try {
            const query = {};

            if (filters.category) {
                const cat = await Category.findOne({ tenDM: filters.category });
                if (cat) {
                    query.category = cat._id;
                }
            }

            if (filters.condition) {
                query.tinhTrangThietBi = filters.condition;
            }

            if (filters.location) {
                query.viTriLuuTru = filters.location;
            }

            if (filters.origin) {
                query.nguonGoc = filters.origin;
            }

            if (filters.search) {
                query.$or = [
                    { tenTB: { $regex: filters.search, $options: 'i' } },
                    { maTB: { $regex: filters.search, $options: 'i' } }
                ];
            }

            const devices = await Device.find(query).populate('category');
            return devices;
        } catch (error) {
            console.error('Error getting devices:', error);
            throw error;
        }
    }

    // Cập nhật trạng thái phiếu mượn
    async updateBorrowRequestStatus(slipId, status) {
        try {
            const result = await BorrowTicket.findOneAndUpdate(
                { maPhieu: slipId },
                { trangThai: status },
                { new: true }
            );
            return result;
        } catch (error) {
            console.error('Error updating borrow request status:', error);
            throw error;
        }
    }

    // Xóa yêu cầu mượn
    async deleteBorrowRequest(slipId) {
        try {
            await BorrowDetail.deleteMany({ maPhieu: slipId });
            const result = await BorrowTicket.findOneAndDelete({ maPhieu: slipId });
            return result;
        } catch (error) {
            console.error('Error deleting borrow request:', error);
            throw error;
        }
    }

    // Lấy chi tiết phiếu trả theo maPhieuTra
    async getReturnSlipById(slipId) {
        try {
            const slip = await ReturnSlip.findOne({ maPhieuTra: slipId })
                .populate('nguoiTraId', 'hoTen email role');

            if (!slip) return null;

            const details = await ReturnDetail.find({ maPhieuTra: slipId });

            // Fetch device info for each detail
            const detailsWithDevice = await Promise.all(details.map(async (detail) => {
                const device = await Device.findOne({ maTB: detail.maTB });
                return {
                    ...detail.toObject(),
                    device: device
                };
            }));

            // Lấy thông tin phiếu mượn liên quan
            const borrowTicket = await BorrowTicket.findOne({ maPhieu: slip.maPhieuMuon })
                .populate('nguoiLapPhieuId', 'hoTen email role');

            return {
                ...slip.toObject(),
                details: detailsWithDevice,
                borrowTicket: borrowTicket
            };
        } catch (error) {
            console.error('Error getting return slip:', error);
            throw error;
        }
    }

    // Lấy danh sách phiếu chờ duyệt (pending)
    async getPendingApprovals(userId, filters = {}) {
        try {
            const query = {};
            if (filters.status) {
                query.trangThai = filters.status;
            }

            // Chỉ thêm userId vào query nếu nó là ObjectId hợp lệ
            if (userId) {
                const mongoose = require('mongoose');
                if (mongoose.Types.ObjectId.isValid(userId)) {
                    query.nguoiLapPhieuId = new mongoose.Types.ObjectId(userId);
                } else {
                    // Nếu userId không hợp lệ, không query theo userId (hoặc có thể throw error)
                    console.warn(`Invalid userId format: ${userId}, skipping user filter`);
                }
            }

            if (filters.id) {
                query.maPhieu = { $regex: filters.id, $options: 'i' };
            }

            if (filters.createdFrom) {
                query.createdAt = { $gte: new Date(filters.createdFrom) };
            }

            if (filters.createdTo) {
                query.createdAt = { ...query.createdAt, $lte: new Date(filters.createdTo) };
            }

            const tickets = await BorrowTicket.find(query).sort({ createdAt: -1 });
            return tickets;
        } catch (error) {
            console.error('Error getting pending approvals:', error);
            throw error;
        }
    }
}

module.exports = new BorrowRepository();
