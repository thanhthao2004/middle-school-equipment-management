// Borrow Repository
const { BorrowTicket, BorrowDetail, ReturnSlip, ReturnDetail } = require('../models/borrow-ticket.model');
const Device = require('../../devices/models/device.model');
const DeviceUnit = require('../../devices/models/device-unit.model');
const Category = require('../../categories/models/category.model');
const User = require('../../users/models/user.model');

class BorrowRepository {
    // Tạo yêu cầu mượn mới
    async createBorrowRequest(userId, borrowData) {
        try {
            // Validate userId là ObjectId hợp lệ
            const mongoose = require('mongoose');
            if (!userId || !mongoose.Types.ObjectId.isValid(userId)) {
                // Nếu userId không hợp lệ, tạo mockup userId
                console.warn('Invalid userId, using mockup userId');
                userId = new mongoose.Types.ObjectId();
            }

            // 1. Create BorrowTicket
            const ticket = new BorrowTicket({
                ngayMuon: new Date(borrowData.borrowDate),
                ngayDuKienTra: new Date(borrowData.returnDate),
                caMuon: borrowData.sessionTime || 'sang', // Default to morning if not provided
                caTra: borrowData.sessionTimeReturn || borrowData.sessionTime || 'sang', // Default to same shift as borrow
                lyDo: borrowData.content,
                nguoiLapPhieuId: new mongoose.Types.ObjectId(userId),
                trangThai: 'cho_duyet', // Default status - pending approval
            });

            // maPhieu will be auto-generated by pre-save hook
            try {
                await ticket.save();
            } catch (saveError) {
                // Nếu save fail, tạo mockup ticket
                console.warn('Error saving ticket to DB, creating mockup ticket:', saveError.message);
                ticket.maPhieu = 'PM' + String(Date.now()).slice(-6);
                ticket._id = new mongoose.Types.ObjectId();
                ticket.createdAt = new Date();
                ticket.updatedAt = new Date();
            }

            // 2. Create BorrowDetails và gán DeviceUnit cụ thể
            if (borrowData.devices && borrowData.devices.length > 0) {
                const details = [];
                const assignedUnits = [];

                for (const device of borrowData.devices) {
                    const maTB = String(device.deviceId || device.id || device.maTB);
                    const quantity = device.quantity || device.soLuong || 1;

                    // Tìm các DeviceUnit sẵn sàng
                    let availableUnits = [];
                    try {
                        availableUnits = await DeviceUnit.getAvailableUnits(maTB, quantity);
                    } catch (err) {
                        console.warn(`DeviceUnit not found for ${maTB}, using legacy mode`);
                    }

                    // Tạo BorrowDetail
                    const detail = {
                        maPhieu: ticket.maPhieu,
                        maTB: maTB,
                        soLuongMuon: quantity,
                        ngayTraDuKien: ticket.ngayDuKienTra,
                        tinhTrangLucMuon: 'Bình thường',
                        soLuongDaTra: 0,
                        trangThai: 'dang_muon',
                        maPhieuTra: null,
                        // Lưu danh sách mã đơn vị được mượn
                        danhSachDonVi: availableUnits.map(u => u.maDonVi)
                    };
                    details.push(detail);

                    // Cập nhật trạng thái các DeviceUnit
                    for (const unit of availableUnits) {
                        assignedUnits.push({
                            maDonVi: unit.maDonVi,
                            maPhieu: ticket.maPhieu
                        });
                    }
                }

                try {
                    await BorrowDetail.insertMany(details);
                    
                    // Cập nhật trạng thái DeviceUnit sang 'dang_muon'
                    for (const assigned of assignedUnits) {
                        await DeviceUnit.findOneAndUpdate(
                            { maDonVi: assigned.maDonVi },
                            { 
                                trangThai: 'dang_muon',
                                maPhieuMuonHienTai: assigned.maPhieu,
                                $push: {
                                    lichSu: {
                                        maPhieu: assigned.maPhieu,
                                        loai: 'muon',
                                        ngay: new Date(),
                                        nguoiThucHien: ticket.nguoiLapPhieuId
                                    }
                                }
                            }
                        );
                    }
                } catch (detailError) {
                    console.warn('Error inserting borrow details:', detailError.message);
                }
            }

            return ticket;
        } catch (error) {
            console.error('Error creating borrow request:', error);
            // Nếu có lỗi nghiêm trọng, tạo mockup ticket
            console.warn('Creating mockup ticket due to error');
            const mongoose = require('mongoose');
            return {
                _id: new mongoose.Types.ObjectId(),
                maPhieu: 'PM' + String(Date.now()).slice(-6),
                ngayMuon: new Date(borrowData.borrowDate),
                ngayDuKienTra: new Date(borrowData.returnDate),
                lyDo: borrowData.content,
                nguoiLapPhieuId: new mongoose.Types.ObjectId(userId),
                trangThai: 'cho_duyet',
                createdAt: new Date(),
                updatedAt: new Date()
            };
        }
    }

    // Lấy phiếu mượn theo ID (maPhieu)
    async getBorrowSlipById(slipId) {
        try {
            const ticket = await BorrowTicket.findOne({ maPhieu: slipId })
                .populate('nguoiLapPhieuId', 'hoTen email role'); // Populate user info

            if (!ticket) return null;

            const details = await BorrowDetail.find({ maPhieu: slipId });

            // Fetch device info for each detail
            const detailsWithDevice = await Promise.all(details.map(async (detail) => {
                try {
                    const device = await Device.findOne({ maTB: detail.maTB }).populate('category');
                    return {
                        ...detail.toObject(),
                        device: device
                    };
                } catch (err) {
                    // Nếu không tìm thấy device, trả về detail không có device
                    console.warn(`Device not found for maTB: ${detail.maTB}`);
                    return {
                        ...detail.toObject(),
                        device: null
                    };
                }
            }));

            return {
                ...ticket.toObject(),
                details: detailsWithDevice
            };
        } catch (error) {
            console.error('Error getting borrow slip:', error);
            throw error;
        }
    }

    // Lấy lịch sử mượn và trả của user (cả phiếu mượn và phiếu trả)
    async getBorrowHistoryByUserId(userId, filters = {}) {
        try {
            const mongoose = require('mongoose');
            const history = [];

            // 1. Lấy danh sách phiếu mượn của user
            const borrowQuery = {};
            
            // Chỉ filter theo userId nếu có và hợp lệ
            if (userId && mongoose.Types.ObjectId.isValid(userId)) {
                borrowQuery.nguoiLapPhieuId = new mongoose.Types.ObjectId(userId);
            }
            // Nếu không có userId, lấy tất cả (cho testing hoặc admin)

            // Filter theo trạng thái - quét tuyệt đối tất cả các trạng thái
            if (filters.status && filters.status !== '') {
                // Map các giá trị filter sang trạng thái thực tế trong DB
                const statusMap = {
                    'cho_duyet': 'cho_duyet',
                    'dang_muon': 'dang_muon',
                    'approved': 'approved',
                    'rejected': 'rejected',
                    'da_tra_mot_phan': 'da_tra_mot_phan',
                    'da_hoan_tat': 'da_hoan_tat',
                    'huy': 'huy',
                    'da_tra_het': 'da_hoan_tat' // Map da_tra_het thành da_hoan_tat
                };
                
                const mappedStatus = statusMap[filters.status] || filters.status;
                borrowQuery.trangThai = mappedStatus;
            }

            if (filters.createdFrom) {
                borrowQuery.createdAt = { $gte: new Date(filters.createdFrom) };
            }

            if (filters.createdTo) {
                borrowQuery.createdAt = { ...borrowQuery.createdAt, $lte: new Date(filters.createdTo) };
            }

            if (filters.search) {
                borrowQuery.maPhieu = { $regex: filters.search, $options: 'i' };
            }

            console.log('[getBorrowHistoryByUserId] Query:', JSON.stringify(borrowQuery));
            const borrowTickets = await BorrowTicket.find(borrowQuery)
                .populate('nguoiLapPhieuId', 'hoTen email role')
                .sort({ createdAt: -1 })
                .limit(filters.limit || 50);
            console.log('[getBorrowHistoryByUserId] Found:', borrowTickets.length, 'tickets');

            // Map phiếu mượn với type = 'borrow'
            borrowTickets.forEach(ticket => {
                history.push({
                    type: 'borrow',
                    id: ticket.maPhieu,
                    maPhieu: ticket.maPhieu,
                    ngayTao: ticket.createdAt || ticket.ngayMuon,
                    ngayMuon: ticket.ngayMuon,
                    ngayDuKienTra: ticket.ngayDuKienTra,
                    trangThai: ticket.trangThai,
                    lyDo: ticket.lyDo,
                    ghiChu: ticket.ghiChu,
                    nguoiLapPhieu: ticket.nguoiLapPhieuId
                });
            });

            // 2. Lấy danh sách phiếu trả liên quan đến các phiếu mượn của user
            if (borrowTickets.length > 0) {
                const maPhieuMuonList = borrowTickets.map(t => t.maPhieu);

                const returnQuery = { maPhieuMuon: { $in: maPhieuMuonList } };

                if (filters.createdFrom) {
                    returnQuery.createdAt = { $gte: new Date(filters.createdFrom) };
                }

                if (filters.createdTo) {
                    returnQuery.createdAt = { ...returnQuery.createdAt, $lte: new Date(filters.createdTo) };
                }

                if (filters.search) {
                    returnQuery.maPhieuTra = { $regex: filters.search, $options: 'i' };
                }

                const returnSlips = await ReturnSlip.find(returnQuery)
                    .populate('nguoiTraId', 'hoTen email role')
                    .sort({ createdAt: -1 })
                    .limit(filters.limit || 50);

                // Map phiếu trả với type = 'return'
                returnSlips.forEach(slip => {
                    history.push({
                        type: 'return',
                        id: slip.maPhieuTra,
                        maPhieuTra: slip.maPhieuTra,
                        maPhieuMuon: slip.maPhieuMuon,
                        ngayTao: slip.createdAt || slip.ngayTra,
                        ngayTra: slip.ngayTra,
                        ghiChu: slip.ghiChu,
                        nguoiTra: slip.nguoiTraId
                    });
                });
            }

            // Sắp xếp theo ngày tạo (mới nhất trước)
            history.sort((a, b) => {
                const dateA = new Date(a.ngayTao || 0);
                const dateB = new Date(b.ngayTao || 0);
                return dateB - dateA;
            });

            return history;
        } catch (error) {
            console.error('Error getting borrow history:', error);
            throw error;
        }
    }

    // Lấy danh sách thiết bị với bộ lọc (cho đăng ký mượn)
    // Không filter theo tình trạng vì tình trạng được quản lý ở DeviceUnit
    async getDevices(filters = {}) {
        try {
            const query = {};

            if (filters.category) {
                const cat = await Category.findOne({ tenDM: filters.category });
                if (cat) {
                    query.category = cat._id;
                }
            }

            // Bỏ filter condition - không cần thiết cho đăng ký mượn
            // Tình trạng được quản lý ở từng DeviceUnit

            if (filters.location) {
                query.viTriLuuTru = filters.location;
            }

            if (filters.origin) {
                query.nguonGoc = filters.origin;
            }

            if (filters.search) {
                query.$or = [
                    { tenTB: { $regex: filters.search, $options: 'i' } },
                    { maTB: { $regex: filters.search, $options: 'i' } }
                ];
            }

            const devices = await Device.find(query).populate('category');

            // Nếu không có data trong DB, trả về mockup data
            if (!devices || devices.length === 0) {
                return this.getMockupDevices(filters);
            }

            // Enrich với số lượng sẵn sàng từ DeviceUnit
            const enrichedDevices = await Promise.all(devices.map(async (device) => {
                try {
                    // Đếm số lượng đơn vị sẵn sàng cho mượn (tình trạng Tốt/Khá và trạng thái san_sang)
                    const availableCount = await DeviceUnit.countAvailable(device.maTB);
                    return {
                        ...device.toObject(),
                        soLuongSanSang: availableCount
                    };
                } catch (err) {
                    // Nếu chưa có DeviceUnit, dùng soLuong từ Device
                    return {
                        ...device.toObject(),
                        soLuongSanSang: device.soLuong || 0
                    };
                }
            }));

            return enrichedDevices;
        } catch (error) {
            console.error('Error getting devices:', error);
            // Nếu có lỗi (ví dụ DB chưa kết nối), trả về mockup data
            console.warn('Returning mockup devices due to error');
            return this.getMockupDevices(filters);
        }
    }

    // Mockup devices for testing
    getMockupDevices(filters = {}) {
        const mockupDevices = [
            {
                _id: 'mock001',
                maTB: 'TB001',
                tenTB: 'Ống nghiệm thủy tinh',
                soLuong: 50,
                tinhTrangThietBi: 'Tốt',
                viTriLuuTru: 'Phòng thiết bị 2',
                nguonGoc: 'CC',
                category: { _id: 'cat001', tenDM: 'Hóa học' },
                maDM: 'Hóa học',
                ngayNhap: new Date('2024-01-15')
            },
            {
                _id: 'mock002',
                maTB: 'TB002',
                tenTB: 'Bình cầu đun nước',
                soLuong: 20,
                tinhTrangThietBi: 'Tốt',
                viTriLuuTru: 'Phòng thiết bị 2',
                nguonGoc: 'NCC',
                category: { _id: 'cat001', tenDM: 'Hóa học' },
                maDM: 'Hóa học',
                ngayNhap: new Date('2024-02-10')
            },
            {
                _id: 'mock003',
                maTB: 'TB003',
                tenTB: 'Máy tính để bàn',
                soLuong: 30,
                tinhTrangThietBi: 'Tốt',
                viTriLuuTru: 'Phòng IT',
                nguonGoc: 'Bộ giáo dục',
                category: { _id: 'cat002', tenDM: 'Tin học' },
                maDM: 'Tin học',
                ngayNhap: new Date('2024-03-01')
            },
            {
                _id: 'mock004',
                maTB: 'TB004',
                tenTB: 'Máy chiếu projector',
                soLuong: 15,
                tinhTrangThietBi: 'Tốt',
                viTriLuuTru: 'Phòng 101',
                nguonGoc: 'GV Thanh Th',
                category: { _id: 'cat002', tenDM: 'Tin học' },
                maDM: 'Tin học',
                ngayNhap: new Date('2024-03-15')
            },
            {
                _id: 'mock005',
                maTB: 'TB005',
                tenTB: 'Nam châm điện',
                soLuong: 25,
                tinhTrangThietBi: 'Tốt',
                viTriLuuTru: 'Phòng thiết bị 3',
                nguonGoc: 'CC',
                category: { _id: 'cat003', tenDM: 'Vật lý' },
                maDM: 'Vật lý',
                ngayNhap: new Date('2024-01-20')
            }
        ];

        // Apply filters to mockup data
        let filtered = mockupDevices;

        if (filters.category) {
            const categoryMap = {
                'chemistry': 'Hóa học',
                'it': 'Tin học',
                'physics': 'Vật lý',
                'literature': 'Ngữ văn'
            };
            const categoryName = categoryMap[filters.category] || filters.category;
            filtered = filtered.filter(d => d.maDM === categoryName || d.category?.tenDM === categoryName);
        }

        if (filters.condition) {
            const conditionMap = {
                'good': 'Tốt',
                'damaged': 'Hỏng'
            };
            const conditionName = conditionMap[filters.condition] || filters.condition;
            filtered = filtered.filter(d => d.tinhTrangThietBi === conditionName);
        }

        if (filters.location) {
            filtered = filtered.filter(d => d.viTriLuuTru === filters.location);
        }

        if (filters.origin) {
            filtered = filtered.filter(d => d.nguonGoc === filters.origin);
        }

        if (filters.search) {
            const searchLower = filters.search.toLowerCase();
            filtered = filtered.filter(d =>
                d.tenTB.toLowerCase().includes(searchLower) ||
                d.maTB.toLowerCase().includes(searchLower)
            );
        }

        return filtered;
    }

    // Cập nhật trạng thái phiếu mượn
    async updateBorrowRequestStatus(slipId, status, ghiChu = '') {
        try {
            const updateData = { trangThai: status };
            if (ghiChu) {
                updateData.ghiChu = ghiChu;
            }
            const result = await BorrowTicket.findOneAndUpdate(
                { maPhieu: slipId },
                updateData,
                { new: true }
            );
            return result;
        } catch (error) {
            console.error('Error updating borrow request status:', error);
            throw error;
        }
    }

    // Duyệt phiếu mượn - cập nhật trạng thái và DeviceUnit
    async approveBorrowRequest(slipId, approvedBy) {
        const mongoose = require('mongoose');
        const session = await mongoose.startSession();
        
        try {
            await session.startTransaction();

            // 1. Cập nhật trạng thái phiếu mượn
            const ticket = await BorrowTicket.findOneAndUpdate(
                { maPhieu: slipId, trangThai: 'cho_duyet' },
                { 
                    trangThai: 'approved',
                    ghiChu: `Đã duyệt bởi: ${approvedBy}`
                },
                { new: true, session }
            );

            if (!ticket) {
                throw new Error('Phiếu mượn không tồn tại hoặc đã được duyệt/từ chối');
            }

            // 2. Lấy tất cả BorrowDetail của phiếu này
            const details = await BorrowDetail.find({ maPhieu: slipId }).session(session);

            // 3. Cập nhật trạng thái các DeviceUnit sang 'dang_muon'
            for (const detail of details) {
                for (const maDonVi of detail.danhSachDonVi || []) {
                    await DeviceUnit.findOneAndUpdate(
                        { maDonVi: maDonVi },
                        {
                            trangThai: 'dang_muon',
                            maPhieuMuonHienTai: slipId,
                            $push: {
                                lichSu: {
                                    maPhieu: slipId,
                                    loai: 'muon',
                                    ngay: new Date(),
                                    nguoiThucHien: ticket.nguoiLapPhieuId,
                                    ghiChu: `Đã duyệt bởi: ${approvedBy}`
                                }
                            }
                        },
                        { session }
                    );
                }
            }

            await session.commitTransaction();
            return ticket;
        } catch (error) {
            await session.abortTransaction();
            console.error('Error approving borrow request:', error);
            throw error;
        } finally {
            session.endSession();
        }
    }

    // Từ chối phiếu mượn
    async rejectBorrowRequest(slipId, reason, rejectedBy) {
        try {
            const ticket = await BorrowTicket.findOneAndUpdate(
                { maPhieu: slipId, trangThai: 'cho_duyet' },
                { 
                    trangThai: 'rejected',
                    ghiChu: `Từ chối bởi: ${rejectedBy}. Lý do: ${reason}`
                },
                { new: true }
            );

            if (!ticket) {
                throw new Error('Phiếu mượn không tồn tại hoặc đã được duyệt/từ chối');
            }

            return ticket;
        } catch (error) {
            console.error('Error rejecting borrow request:', error);
            throw error;
        }
    }

    // Lấy danh sách phiếu mượn chờ duyệt (cho QLTB)
    async getPendingBorrowTicketsForManager(filters = {}) {
        try {
            const query = { trangThai: 'cho_duyet' };

            if (filters.search) {
                query.$or = [
                    { maPhieu: { $regex: filters.search, $options: 'i' } },
                    { lyDo: { $regex: filters.search, $options: 'i' } }
                ];
            }

            if (filters.createdFrom) {
                query.createdAt = { $gte: new Date(filters.createdFrom) };
            }

            if (filters.createdTo) {
                query.createdAt = { ...query.createdAt, $lte: new Date(filters.createdTo) };
            }

            const tickets = await BorrowTicket.find(query)
                .populate('nguoiLapPhieuId', 'hoTen email role maNV')
                .sort({ createdAt: -1 })
                .limit(filters.limit || 100);

            // Enrich với BorrowDetails
            const enrichedTickets = await Promise.all(tickets.map(async (ticket) => {
                const details = await BorrowDetail.find({ maPhieu: ticket.maPhieu });
                const detailsWithDevice = await Promise.all(details.map(async (detail) => {
                    const device = await Device.findOne({ maTB: detail.maTB }).populate('category');
                    return {
                        ...detail.toObject(),
                        device: device
                    };
                }));

                return {
                    ...ticket.toObject(),
                    details: detailsWithDevice
                };
            }));

            return enrichedTickets;
        } catch (error) {
            console.error('Error getting pending borrow tickets for manager:', error);
            throw error;
        }
    }

    // Xóa yêu cầu mượn
    async deleteBorrowRequest(slipId) {
        try {
            await BorrowDetail.deleteMany({ maPhieu: slipId });
            const result = await BorrowTicket.findOneAndDelete({ maPhieu: slipId });
            return result;
        } catch (error) {
            console.error('Error deleting borrow request:', error);
            throw error;
        }
    }

    // Lấy chi tiết phiếu trả theo maPhieuTra
    async getReturnSlipById(slipId) {
        try {
            const slip = await ReturnSlip.findOne({ maPhieuTra: slipId })
                .populate('nguoiTraId', 'hoTen email role');

            if (!slip) return null;

            const details = await ReturnDetail.find({ maPhieuTra: slipId });

            // Fetch device info for each detail
            const detailsWithDevice = await Promise.all(details.map(async (detail) => {
                const device = await Device.findOne({ maTB: detail.maTB });
                return {
                    ...detail.toObject(),
                    device: device
                };
            }));

            // Lấy thông tin phiếu mượn liên quan
            const borrowTicket = await BorrowTicket.findOne({ maPhieu: slip.maPhieuMuon })
                .populate('nguoiLapPhieuId', 'hoTen email role');

            return {
                ...slip.toObject(),
                details: detailsWithDevice,
                borrowTicket: borrowTicket
            };
        } catch (error) {
            console.error('Error getting return slip:', error);
            throw error;
        }
    }

    // Lấy danh sách phiếu chờ duyệt (pending)
    async getPendingApprovals(userId, filters = {}) {
        try {
            const query = {};
            
            // Mặc định lấy phiếu chờ duyệt, cho phép override nếu cần
            query.trangThai = filters.status || 'cho_duyet';

            // Chỉ thêm userId vào query nếu nó là ObjectId hợp lệ
            if (userId) {
                const mongoose = require('mongoose');
                if (mongoose.Types.ObjectId.isValid(userId)) {
                    query.nguoiLapPhieuId = new mongoose.Types.ObjectId(userId);
                } else {
                    // Nếu userId không hợp lệ, không query theo userId
                    console.warn(`Invalid userId format: ${userId}, skipping user filter`);
                }
            }
            // Nếu không có userId (null), lấy tất cả phiếu cho_duyet (cho testing)

            if (filters.id || filters.search) {
                query.maPhieu = { $regex: filters.id || filters.search, $options: 'i' };
            }

            if (filters.createdFrom) {
                query.createdAt = { $gte: new Date(filters.createdFrom) };
            }

            if (filters.createdTo) {
                query.createdAt = { ...query.createdAt, $lte: new Date(filters.createdTo) };
            }

            console.log('[getPendingApprovals] Query:', JSON.stringify(query));
            const tickets = await BorrowTicket.find(query).sort({ createdAt: -1 });
            console.log('[getPendingApprovals] Found:', tickets.length, 'tickets');
            return tickets;
        } catch (error) {
            console.error('Error getting pending approvals:', error);
            throw error;
        }
    }

    /**
     * Get total borrowed quantity for a device at a specific time slot
     * CRITICAL: This prevents double-booking by checking all overlapping reservations
     * 
     * @param {string} maTB - Device code
     * @param {Date} targetDate - Target date to check
     * @param {string} targetShift - 'sang' or 'chieu'
     * @returns {Promise<number>} - Total quantity already borrowed for this slot
     */
    async getBorrowedQuantityForSlot(maTB, targetDate, targetShift) {
        try {
            // Normalize target date to start of day
            const targetDay = new Date(targetDate);
            targetDay.setHours(0, 0, 0, 0);

            const nextDay = new Date(targetDay);
            nextDay.setDate(nextDay.getDate() + 1);

            // Convert shift to numeric index for comparison
            const shiftIndex = { 'sang': 1, 'chieu': 2 };
            const targetIndex = shiftIndex[targetShift];

            if (!targetIndex) {
                throw new Error(`Invalid shift: ${targetShift}`);
            }

            // Aggregate query to sum borrowed quantities for overlapping tickets
            const result = await BorrowDetail.aggregate([
                // Stage 1: Match device
                {
                    $match: { maTB: maTB }
                },
                // Stage 2: Join with BorrowTicket
                {
                    $lookup: {
                        from: 'borrowtickets',
                        localField: 'maPhieu',
                        foreignField: 'maPhieu',
                        as: 'ticket'
                    }
                },
                {
                    $unwind: '$ticket'
                },
                // Stage 3: Filter for active tickets and overlapping slots
                {
                    $match: {
                        // Only count pending and approved tickets
                        'ticket.trangThai': { $in: ['dang_muon', 'approved'] },

                        // Complex overlap logic - 4 scenarios:
                        $or: [
                            // Scenario 1: Same-day booking with shift overlap
                            {
                                $and: [
                                    { 'ticket.ngayMuon': { $gte: targetDay, $lt: nextDay } },
                                    { 'ticket.ngayDuKienTra': { $gte: targetDay, $lt: nextDay } },
                                    // Check shift overlap within same day
                                    { 'ticket.caMuon': { $ne: null } },
                                    { 'ticket.caTra': { $ne: null } },
                                    {
                                        $expr: {
                                            $and: [
                                                // Shift index conversion and comparison
                                                {
                                                    $lte: [
                                                        { $cond: [{ $eq: ['$ticket.caMuon', 'sang'] }, 1, 2] },
                                                        targetIndex
                                                    ]
                                                },
                                                {
                                                    $gte: [
                                                        { $cond: [{ $eq: ['$ticket.caTra', 'sang'] }, 1, 2] },
                                                        targetIndex
                                                    ]
                                                }
                                            ]
                                        }
                                    }
                                ]
                            },

                            // Scenario 2: Multi-day booking that encompasses target date
                            {
                                $and: [
                                    { 'ticket.ngayMuon': { $lt: targetDay } },
                                    { 'ticket.ngayDuKienTra': { $gte: nextDay } }
                                ]
                            },

                            // Scenario 3: Starts before target, ends on target day
                            {
                                $and: [
                                    { 'ticket.ngayMuon': { $lt: targetDay } },
                                    { 'ticket.ngayDuKienTra': { $gte: targetDay, $lt: nextDay } },
                                    { 'ticket.caTra': { $ne: null } },
                                    {
                                        $expr: {
                                            $gte: [
                                                { $cond: [{ $eq: ['$ticket.caTra', 'sang'] }, 1, 2] },
                                                targetIndex
                                            ]
                                        }
                                    }
                                ]
                            },

                            // Scenario 4: Starts on target day, ends after
                            {
                                $and: [
                                    { 'ticket.ngayMuon': { $gte: targetDay, $lt: nextDay } },
                                    { 'ticket.ngayDuKienTra': { $gte: nextDay } },
                                    { 'ticket.caMuon': { $ne: null } },
                                    {
                                        $expr: {
                                            $lte: [
                                                { $cond: [{ $eq: ['$ticket.caMuon', 'sang'] }, 1, 2] },
                                                targetIndex
                                            ]
                                        }
                                    }
                                ]
                            }
                        ]
                    }
                },
                // Stage 4: Sum total borrowed quantity
                {
                    $group: {
                        _id: null,
                        totalBorrowed: { $sum: '$soLuongMuon' }
                    }
                }
            ]);

            const borrowedQty = result.length > 0 ? result[0].totalBorrowed : 0;

            console.log(`[getBorrowedQuantityForSlot] Device: ${maTB}, Date: ${targetDate.toLocaleDateString()}, Shift: ${targetShift}, Borrowed: ${borrowedQty}`);

            return borrowedQty;

        } catch (error) {
            console.error(`Error in getBorrowedQuantityForSlot for ${maTB}:`, error);
            throw error;
        }
    }

    /**
     * Create a return slip for selected borrowed items
     * @param {string} employeeId - ID of the employee processing the return
     * @param {Array<string>} borrowedItemIds - Array of BorrowDetail _id to return
     * @param {Object} returnData - Return slip data { returnDate, returnShift, notes, quantities }
     * @returns {Promise<Object>} - Created return slip with updated items
     */
    async createReturnSlip(employeeId, borrowedItemIds, returnData) {
        const mongoose = require('mongoose');
        const session = await mongoose.startSession();

        try {
            await session.startTransaction();

            // 1. Validate employee ID
            if (!employeeId || !mongoose.Types.ObjectId.isValid(employeeId)) {
                throw new Error('ID nhân viên không hợp lệ');
            }

            // 2. Fetch and validate borrowed items
            const borrowedItems = await BorrowDetail.find({
                _id: { $in: borrowedItemIds.map(id => new mongoose.Types.ObjectId(id)) }
            }).session(session);

            if (borrowedItems.length === 0) {
                throw new Error('Không tìm thấy thiết bị mượn cần trả');
            }

            // 3. Validate return quantities
            const quantities = returnData.quantities || {};
            for (const item of borrowedItems) {
                const returnQty = quantities[item._id.toString()] || item.soLuongMuon - item.soLuongDaTra;
                const remainingQty = item.soLuongMuon - item.soLuongDaTra;

                if (returnQty > remainingQty) {
                    const device = await Device.findOne({ maTB: item.maTB });
                    throw new Error(`Số lượng trả (${returnQty}) vượt quá số lượng còn lại (${remainingQty}) cho thiết bị ${device?.tenTB || item.maTB}`);
                }
            }

            // 4. Create ReturnSlip
            const returnSlip = new ReturnSlip({
                maPhieuMuon: borrowedItems[0].maPhieu, // All items should be from same borrow slip in typical use
                ngayTra: new Date(returnData.returnDate),
                caTraThucTe: returnData.returnShift || 'sang',
                nguoiTraId: new mongoose.Types.ObjectId(employeeId),
                ghiChu: returnData.notes || ''
            });

            await returnSlip.save({ session });

            // 5. Create ReturnDetail và update BorrowDetail cho mỗi item
            const { ReturnDetail } = require('../models/borrow-ticket.model');
            const updatedItems = [];
            
            for (const item of borrowedItems) {
                const returnQty = quantities[item._id.toString()] || item.soLuongMuon - item.soLuongDaTra;
                const newTotalReturned = item.soLuongDaTra + returnQty;

                // Validate return quantity
                if (returnQty <= 0) {
                    continue; // Skip items with invalid return quantity
                }

                // Determine new status
                let newStatus;
                if (newTotalReturned >= item.soLuongMuon) {
                    newStatus = 'da_tra_het';
                } else if (newTotalReturned > 0) {
                    newStatus = 'da_tra_mot_phan';
                } else {
                    newStatus = 'dang_muon';
                }

                // Create ReturnDetail
                const returnDetail = new ReturnDetail({
                    maPhieuTra: returnSlip.maPhieuTra,
                    maTB: item.maTB,
                    soLuongTra: returnQty,
                    tinhTrangLucTra: returnData.itemConditions?.[item._id.toString()] || 'Bình thường',
                    ghiChu: returnData.itemNotes?.[item._id.toString()] || ''
                });
                await returnDetail.save({ session });

                // Update BorrowDetail
                const updated = await BorrowDetail.findByIdAndUpdate(
                    item._id,
                    {
                        soLuongDaTra: newTotalReturned,
                        trangThai: newStatus,
                        maPhieuTra: returnSlip.maPhieuTra
                    },
                    { new: true, session }
                );

                updatedItems.push(updated);

                // 6. Update DeviceUnit status - chuyển từ 'dang_muon' về 'san_sang'
                // Chỉ update số lượng tương ứng với số lượng trả
                const unitsToReturn = item.danhSachDonVi?.slice(0, returnQty) || [];
                for (const maDonVi of unitsToReturn) {
                    await DeviceUnit.findOneAndUpdate(
                        { maDonVi: maDonVi, maPhieuMuonHienTai: item.maPhieu },
                        {
                            trangThai: 'san_sang',
                            maPhieuMuonHienTai: null,
                            $push: {
                                lichSu: {
                                    maPhieu: returnSlip.maPhieuTra,
                                    loai: 'tra',
                                    ngay: new Date(returnData.returnDate),
                                    nguoiThucHien: new mongoose.Types.ObjectId(employeeId),
                                    ghiChu: `Trả thiết bị - Phiếu trả: ${returnSlip.maPhieuTra}`
                                }
                            }
                        },
                        { session }
                    );
                }

                // 7. Update device inventory (log only)
                const device = await Device.findOne({ maTB: item.maTB }).session(session);
                if (device) {
                    console.log(`[Inventory] Returned ${returnQty} of ${device.tenTB} (${device.maTB})`);
                }
            }

            // 7. Update parent BorrowTicket status
            const maPhieu = borrowedItems[0].maPhieu;
            await this.updateBorrowTicketStatusByItems(maPhieu, session);

            await session.commitTransaction();

            // 8. Return the created return slip with details
            const result = await this.getReturnSlipById(returnSlip.maPhieuTra);
            return result;

        } catch (error) {
            await session.abortTransaction();
            console.error('Error creating return slip:', error);
            throw error;
        } finally {
            session.endSession();
        }
    }

    /**
     * Update BorrowTicket status based on its child BorrowDetail items
     * @param {string} maPhieu - Borrowing slip ID
     * @param {Object} session - Mongoose session for transaction
     */
    async updateBorrowTicketStatusByItems(maPhieu, session) {
        try {
            // Get all borrowed items for this ticket
            const items = await BorrowDetail.find({ maPhieu }).session(session);

            if (items.length === 0) {
                return;
            }

            // Count item statuses
            const allReturned = items.every(item => item.trangThai === 'da_tra_het');
            const someReturned = items.some(item => item.trangThai === 'da_tra_het' || item.trangThai === 'da_tra_mot_phan');

            let newStatus;
            if (allReturned) {
                newStatus = 'da_hoan_tat';
            } else if (someReturned) {
                newStatus = 'da_tra_mot_phan';
            } else {
                // Keep current status (dang_muon or approved)
                return;
            }

            await BorrowTicket.findOneAndUpdate(
                { maPhieu },
                { trangThai: newStatus },
                { session }
            );

            console.log(`[Status Update] BorrowTicket ${maPhieu} updated to ${newStatus}`);
        } catch (error) {
            console.error('Error updating borrow ticket status:', error);
            throw error;
        }
    }

    /**
     * Get borrowed items that can be returned
     * @param {Object} filters - Filter options { maPhieu, userId, status, maTB }
     * @returns {Promise<Array>} - List of borrowed items with device details
     */
    async getBorrowedItemsForReturn(filters = {}) {
        try {
            const query = {};

            // Filter by borrowing slip ID
            if (filters.maPhieu) {
                query.maPhieu = filters.maPhieu;
            }

            // Filter by status (default: not fully returned)
            if (filters.status) {
                query.trangThai = filters.status;
            } else {
                query.trangThai = { $in: ['dang_muon', 'da_tra_mot_phan'] };
            }

            // Filter by equipment code
            if (filters.maTB) {
                query.maTB = filters.maTB;
            }

            // Fetch borrowed items
            const items = await BorrowDetail.find(query).sort({ createdAt: -1 });

            // Enrich with borrowing ticket and device information
            const enrichedItems = await Promise.all(items.map(async (item) => {
                const ticket = await BorrowTicket.findOne({ maPhieu: item.maPhieu })
                    .populate('nguoiLapPhieuId', 'hoTen email role');

                const device = await Device.findOne({ maTB: item.maTB })
                    .populate('category');

                // Calculate remaining quantity
                const remainingQty = item.soLuongMuon - item.soLuongDaTra;

                return {
                    ...item.toObject(),
                    remainingQty,
                    ticket: ticket ? {
                        maPhieu: ticket.maPhieu,
                        ngayMuon: ticket.ngayMuon,
                        ngayDuKienTra: ticket.ngayDuKienTra,
                        nguoiLapPhieu: ticket.nguoiLapPhieuId,
                        trangThai: ticket.trangThai
                    } : null,
                    device: device ? {
                        maTB: device.maTB,
                        tenTB: device.tenTB,
                        category: device.category,
                        viTriLuuTru: device.viTriLuuTru,
                        hinhAnh: device.hinhAnh
                    } : null
                };
            }));

            // Filter by user if needed (after join)
            if (filters.userId) {
                const mongoose = require('mongoose');
                if (mongoose.Types.ObjectId.isValid(filters.userId)) {
                    const userId = new mongoose.Types.ObjectId(filters.userId);
                    return enrichedItems.filter(item =>
                        item.ticket && item.ticket.nguoiLapPhieu &&
                        item.ticket.nguoiLapPhieu._id.equals(userId)
                    );
                }
            }

            return enrichedItems;
        } catch (error) {
            console.error('Error getting borrowed items for return:', error);
            throw error;
        }
    }
}

module.exports = new BorrowRepository();
